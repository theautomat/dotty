import { firebaseAdmin } from './firebase-admin-config';
import type { Firestore } from 'firebase-admin/firestore';

/**
 * Clue Service
 *
 * Handles storage and retrieval of treasure clue purchases.
 * Clues are stored as a subcollection under each treasure document.
 * Each clue purchase triggers an AI generation cloud function.
 */

export interface ClueData {
  signature: string;
  walletAddress: string;
  treasureId: string;
  metadata?: {
    blockTime?: number;
    slot?: number;
    fee?: number;
    programId?: string;
    clueRecordPda?: string;
    [key: string]: any;
  };
}

export interface Clue {
  // Transaction identifiers
  txSignature: string;
  walletAddress: string;
  treasureId: string;

  // Clue content (generated by AI cloud function)
  clueText?: string;
  status: 'pending' | 'generating' | 'completed' | 'failed';
  error?: string;

  // Timestamps
  purchasedAt: string;
  createdAt: string;
  updatedAt: string;
  generatedAt?: string;

  // Blockchain metadata
  metadata: {
    blockTime: number | null;
    slot: number | null;
    fee: number | null;
    programId: string | null;
    clueRecordPda: string;
    [key: string]: any;
  };
}

export interface ClueFilters {
  limit?: number;
  walletAddress?: string;
  status?: 'pending' | 'generating' | 'completed' | 'failed';
}

class ClueService {
  /**
   * Get Firestore instance
   * @private
   */
  private _getDb(): Firestore {
    const db = firebaseAdmin.getFirestore();
    if (!db) {
      throw new Error('Firebase Admin not initialized');
    }
    return db;
  }

  /**
   * Check if Firebase Admin is initialized
   */
  isReady(): boolean {
    try {
      this._getDb();
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Save a clue purchase from transaction monitor webhook
   *
   * @param clueData - Clue data from webhook
   * @returns Saved document reference
   */
  async saveClue(clueData: ClueData): Promise<{
    success: boolean;
    id: string;
    clue: Clue;
  }> {
    try {
      const db = this._getDb();

      // Validate required fields
      if (!clueData.signature) {
        throw new Error('Transaction signature is required');
      }
      if (!clueData.walletAddress) {
        throw new Error('Wallet address is required');
      }
      if (!clueData.treasureId) {
        throw new Error('Treasure ID is required');
      }

      // Prepare clue document
      const clue: Clue = {
        // Transaction identifiers
        txSignature: clueData.signature,
        walletAddress: clueData.walletAddress,
        treasureId: clueData.treasureId,

        // Clue content (to be generated by cloud function)
        status: 'pending',

        // Timestamps
        purchasedAt: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),

        // Blockchain metadata
        metadata: {
          blockTime: clueData.metadata?.blockTime || null,
          slot: clueData.metadata?.slot || null,
          fee: clueData.metadata?.fee || null,
          programId: clueData.metadata?.programId || null,
          clueRecordPda: clueData.metadata?.clueRecordPda || '',
          ...clueData.metadata
        }
      };

      // Save to Firestore as subcollection under treasure
      await db
        .collection('treasures')
        .doc(clueData.treasureId)
        .collection('clues')
        .doc(clueData.signature) // Use signature as document ID for idempotency
        .set(clue, { merge: true }); // Merge to handle duplicate webhooks

      console.log(`✅ Clue purchase saved: ${clueData.signature} for treasure ${clueData.treasureId}`);

      return {
        success: true,
        id: clueData.signature,
        clue
      };

    } catch (error) {
      console.error('❌ Error saving clue:', error);
      throw error;
    }
  }

  /**
   * Get a specific clue by transaction signature
   *
   * @param treasureId - Treasure ID
   * @param signature - Transaction signature
   * @returns Clue document or null if not found
   */
  async getClue(treasureId: string, signature: string): Promise<(Clue & { id: string }) | null> {
    try {
      const db = this._getDb();

      const doc = await db
        .collection('treasures')
        .doc(treasureId)
        .collection('clues')
        .doc(signature)
        .get();

      if (!doc.exists) {
        return null;
      }

      return {
        id: doc.id,
        ...doc.data() as Clue
      };

    } catch (error) {
      console.error('❌ Error getting clue:', error);
      throw error;
    }
  }

  /**
   * Get all clues for a specific treasure
   *
   * @param treasureId - Treasure ID
   * @param filters - Query filters
   * @returns Array of clue documents
   */
  async getCluesForTreasure(
    treasureId: string,
    filters: ClueFilters = {}
  ): Promise<Array<Clue & { id: string }>> {
    try {
      const db = this._getDb();
      const {
        limit = 100,
        walletAddress = null,
        status = null
      } = filters;

      let query: FirebaseFirestore.Query = db
        .collection('treasures')
        .doc(treasureId)
        .collection('clues')
        .orderBy('purchasedAt', 'desc')
        .limit(limit);

      // Add wallet filter if specified
      if (walletAddress) {
        query = query.where('walletAddress', '==', walletAddress);
      }

      // Add status filter if specified
      if (status) {
        query = query.where('status', '==', status);
      }

      const snapshot = await query.get();

      const clues: Array<Clue & { id: string }> = [];
      snapshot.forEach(doc => {
        clues.push({
          id: doc.id,
          ...doc.data() as Clue
        });
      });

      return clues;

    } catch (error) {
      console.error('❌ Error getting clues for treasure:', error);
      throw error;
    }
  }

  /**
   * Get clues by wallet address across all treasures
   *
   * @param walletAddress - Wallet address to query
   * @returns Array of clue documents
   */
  async getCluesByWallet(walletAddress: string): Promise<Array<Clue & { id: string }>> {
    try {
      const db = this._getDb();

      // Get all treasures
      const treasuresSnapshot = await db.collection('treasures').get();

      const allClues: Array<Clue & { id: string }> = [];

      // Query clues for each treasure
      for (const treasureDoc of treasuresSnapshot.docs) {
        const cluesSnapshot = await db
          .collection('treasures')
          .doc(treasureDoc.id)
          .collection('clues')
          .where('walletAddress', '==', walletAddress)
          .orderBy('purchasedAt', 'desc')
          .get();

        cluesSnapshot.forEach(clueDoc => {
          allClues.push({
            id: clueDoc.id,
            ...clueDoc.data() as Clue
          });
        });
      }

      // Sort by purchase date
      allClues.sort((a, b) =>
        new Date(b.purchasedAt).getTime() - new Date(a.purchasedAt).getTime()
      );

      return allClues;

    } catch (error) {
      console.error('❌ Error getting clues by wallet:', error);
      throw error;
    }
  }

  /**
   * Update clue with AI-generated text
   *
   * @param treasureId - Treasure ID
   * @param signature - Transaction signature
   * @param clueText - AI-generated clue text
   * @returns Update result
   */
  async updateClueText(
    treasureId: string,
    signature: string,
    clueText: string
  ): Promise<{ success: boolean; message: string }> {
    try {
      const db = this._getDb();

      const updateData: Partial<Clue> = {
        clueText,
        status: 'completed',
        generatedAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      await db
        .collection('treasures')
        .doc(treasureId)
        .collection('clues')
        .doc(signature)
        .update(updateData);

      console.log(`✅ Clue text updated: ${signature}`);

      return {
        success: true,
        message: `Clue text updated successfully`
      };

    } catch (error) {
      console.error('❌ Error updating clue text:', error);
      throw error;
    }
  }

  /**
   * Update clue status (for tracking AI generation progress)
   *
   * @param treasureId - Treasure ID
   * @param signature - Transaction signature
   * @param status - New status
   * @param error - Error message if failed
   * @returns Update result
   */
  async updateClueStatus(
    treasureId: string,
    signature: string,
    status: Clue['status'],
    error?: string
  ): Promise<{ success: boolean; message: string }> {
    try {
      const db = this._getDb();

      const updateData: Partial<Clue> = {
        status,
        updatedAt: new Date().toISOString()
      };

      if (error) {
        updateData.error = error;
      }

      await db
        .collection('treasures')
        .doc(treasureId)
        .collection('clues')
        .doc(signature)
        .update(updateData);

      console.log(`✅ Clue status updated: ${signature} -> ${status}`);

      return {
        success: true,
        message: `Clue status updated successfully`
      };

    } catch (error) {
      console.error('❌ Error updating clue status:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const clueService = new ClueService();
